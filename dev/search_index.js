var documenterSearchIndex = {"docs":
[{"location":"#STSP.jl","page":"STSP.jl","title":"STSP.jl","text":"","category":"section"},{"location":"","page":"STSP.jl","title":"STSP.jl","text":"Pages = [\"index.md\"]","category":"page"},{"location":"#Index","page":"STSP.jl","title":"Index","text":"","category":"section"},{"location":"","page":"STSP.jl","title":"STSP.jl","text":"Pages = [\"index.md\"]","category":"page"},{"location":"","page":"STSP.jl","title":"STSP.jl","text":"Modules = [STSP]","category":"page"},{"location":"#STSP.AbstractEdge","page":"STSP.jl","title":"STSP.AbstractEdge","text":"Type abstrait dont d'autres types d'arêtes dériveront.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.AbstractGraph","page":"STSP.jl","title":"STSP.AbstractGraph","text":"Type abstrait dont d'autres types de graphes dériveront.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.AbstractNode","page":"STSP.jl","title":"STSP.AbstractNode","text":"Type abstrait dont d'autres types de noeuds dériveront.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.AbstractQueue","page":"STSP.jl","title":"STSP.AbstractQueue","text":"Type abstrait dont d'autres types de files dériveront.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.Adjacency","page":"STSP.jl","title":"STSP.Adjacency","text":"Alias de type pour représenter un dictionnaire d'adjacence\n\n\n\n\n\n","category":"type"},{"location":"#STSP.Edge","page":"STSP.jl","title":"STSP.Edge","text":"Type représentant les arêtes d'un graphe.\n\nExemple:\n\n    arête = Edge(\"E411\", 40000, \"Ottignies-Louvain-la-Neuve\", \"Namur\")\n    arête = Edge(\"E40\", 35000, \"Bruxelles\", \"Gand\")\n    arête = Edge(\"Meuse\", 45000, \"Liège\", \"Namur\")\n\n\n\n\n\n","category":"type"},{"location":"#STSP.Edge-Union{Tuple{U}, Tuple{String, String, U}} where U<:Number","page":"STSP.jl","title":"STSP.Edge","text":"Construit une arête à partir d'un poids et de deux identifiants de noeud.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.Edge-Union{Tuple{U}, Tuple{T}, Tuple{T, T, U}} where {T, U<:Number}","page":"STSP.jl","title":"STSP.Edge","text":"Construit une arête à partir d'un poids et de deux identifiants de noeud sous forme de nombre.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.Forest","page":"STSP.jl","title":"STSP.Forest","text":"Type representant une forêt comme un ensemble d'identifiants de noeuds pointant vers des arbres.\n\nLes identifiants dérivent des identifiants des noeuds d'un graphe. A partir de l'identifiant du noeud d'un graphe, cette structure permet de trouver l'arbre associé dans le dictionnaire trees`. Si l'identifiant d'un noeud pointe vers un arbre dont le parent a le même identifiant, alors ce noeud est une \"racine\".  Les \"racines\" de l'arbre sont utiles pour les fusionner et pour vérifier l'existence de cycles.\n\nVoir la documentation de la fonction merge! pour plus de détails.\n\nLe nombre de \"racines\" contenue dans la forêt est également stocké dans l'attribut num_roots.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.Forest-Union{Tuple{Graph{T, U}}, Tuple{U}, Tuple{T}} where {T, U}","page":"STSP.jl","title":"STSP.Forest","text":"Forest(G; mode)\n\nInitialise une forêt de composantes connexes à partir d'un graphe. Un arbre de taille 1 ou de rang 0 est créé par noeud du graphe. Cette fonction est conçue pour servir à l'initialisation de l'algorithme de Kruskal.\n\nArguments\n\nG (Graph): le graphe à partir duquel construire une forêt de composantes connexes\nmode (String=\"size\") : (\"size\" ou \"rank\"). L'attribut à initialiser dans chaque arbre créé\n\n\n\n\n\n","category":"method"},{"location":"#STSP.Graph","page":"STSP.jl","title":"STSP.Graph","text":"Type representant un graphe comme un ensemble de noeuds et d'arêtes.\n\nExemple :\n\nnode1 = Node(\"Joe\", 3.14)\nnode2 = Node(\"Steve\", exp(1))\nnode3 = Node(\"Jill\", 4.12)\nedge1 = Edge(\"Joe-Steve\", 2, \"Joe\", \"Steve\")\nedge1 = Edge(\"Joe-Jill\", -5, \"Joe\", \"Jill\")\nG = Graph(\"Ick\", [node1, node2, node3], [edge1,edge2])\n\nDe façon interne, les noeuds et les arêtes sont stockés en tant que dictionnaire. Ceci permet de retrouver des noeuds/arêtes rapidement à partir de leurs identifiants. De plus, l'adjacence est stockée en tant que dictionnaire ce qui permet facilement d'accéder aux voisins d'un noeud. Attention, tous les noeuds doivent avoir des données de même type. Toutes les arêtes doivent également avoir des données du même type mais pas nécessairement le même type que celui des noeuds. De plus, les noms des noeuds et des arêtes doivent être uniques.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.Graph-Union{Tuple{U}, Tuple{T}, Tuple{String, Array{Node{T}, 1}, Array{Edge{U}, 1}}} where {T, U}","page":"STSP.jl","title":"STSP.Graph","text":"Graph(name::String, nodes::Vector{Node{T}}, edges::Vector{Edge{U}})\n\nConstruit un graphe à partir d'une liste de noeud et d'arêtes.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.Node","page":"STSP.jl","title":"STSP.Node","text":"Type représentant les noeuds d'un graphe.\n\nExemple:\n\n    noeud = Node(\"James\", [π, exp(1)])\n    noeud = Node(\"Kirk\", \"guitar\")\n    noeud = Node(\"Lars\", 2)\n\n\n\n\n\n","category":"type"},{"location":"#STSP.PrimPriorityQueue","page":"STSP.jl","title":"STSP.PrimPriorityQueue","text":"Type représentant une implémentation d'une file de priorité permettant une implémentation efficace de l'algorithme de Prim.\n\nCette structure de donnée stocke des identifiants de noeuds ainsi que des priorités dont le type est paramétrique dans le dictionnaire items.  L'ordre de supression des éléments de la file est indiqué par order dont la valeur par défaut est \"max\". Lors d'un appel à popfirst!, si l'ordre est max, la paire identifiant-priorité ayant la priorité la plus élevée est supprimée. Si l'ordre choisi est \"min\" alors c'est la paire ayant la plus petite priorité qui est supprimée.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.PrimPriorityQueue-Union{Tuple{}, Tuple{U}} where U","page":"STSP.jl","title":"STSP.PrimPriorityQueue","text":"PrimPriorityQueue{U}()\n\nInitialise une file de priorité de Prim de type paramétrique U vide.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.Tree","page":"STSP.jl","title":"STSP.Tree","text":"Type representant un arbre comme l'identifiant d'un parent, une liste d'identifiants d'enfants et une taille ou un rang d'arbre.\n\nL'identifiant d'un parent dérive de l'identifiant du noeud d'un graphe. Les identifiants des enfants dérivent de l'identifiant de noeuds d'un graphe. La taille d'un arbre est définie comme le nombre d'arbres qui ont cet arbre comme parent. Le rang d'un arbre est un attribut utile pour la procédure d'union de composantes connexes par le rang. Un seul attribut parmi la taille et le rang n'est pas nul. Ce type est principalement utile pour le type Forest.\n\n\n\n\n\n","category":"type"},{"location":"#STSP.Tree-Tuple{String, Int64}","page":"STSP.jl","title":"STSP.Tree","text":"Tree(parent_id, value; mode)\n\nInitialise un arbre à partir de l'identifiant de sa racine et d'une valeur de taille et de rang (option choisie par l'argumment mode).\n\nArguments\n\nparent_id (String): l'identifiant du noeud constituant la racine de l'arbre\nvalue (Int64): la valeur numérique de la taille ou du rang\nmode (String=\"size\"): (\"size\" ou \"rank\"). L'attribut qui doit être initialisé à la valeur value (la taille ou le rang).\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{STSP.AbstractQueue}","page":"STSP.jl","title":"Base.length","text":"length(q)\n\nRetourne le nombre d'éléments d'une file abstraite.\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge!-Tuple{Forest, String, String}","page":"STSP.jl","title":"Base.merge!","text":"merge!(forest, root_id1, root_id2; mode)\n\nFonction permettant de fusionner deux arbres à partir de deux identifiants qui ont la propriété d'être des \"racines\". La fusion s'opère en redéfinissant le parent d'une \"racine\" par l'autre \"racine\". De plus, la fusion effectue la compression de chemin: chaque noeud de l'arbre fusionné se connecte à la racine de l'arbre qui englobe.\n\nPour choisir quelle racine prend l'autre racine comme enfant, 2 possibilités sont proposées.\n\nUnion par la taille\n\nLa taille des arbres associés est comparée ; l'arbre de plus grande taille englobe l'autre. Cela nécessite que les attributs size des arbres de la forêt ne soient pas nuls.\n\nUnion par le rang\n\nLes rangs sont comparés et incrémentés selon la politique classique d'union par le rang.\n\nArguments\n\nforest (Forest): forêt dans laquelle se trouvent les 2 arbres à fusionner\nroot_id1 (String): identifiant de la racine du premier arbre participant à la fusion\nroot_id2 (String): identifiant de la racine du second arbre participant à la fusion\nmode (String=\"size\"): (\"size\" ou \"rank\"). Indique le critère retenu pour l'union.\n\nType de retour\n\nAucun : fonction in-place.\n\n\n\n\n\n","category":"method"},{"location":"#Base.popfirst!-Tuple{PrimPriorityQueue}","page":"STSP.jl","title":"Base.popfirst!","text":"popfirst!(q)\n\nSi l'ordre de la file (stocké dans q.order) est \"max\", retire et renvoie un élément de la file ayant la plus grande priorité. Si l'ordre de la file (stocké dans q.order) est \"min\", retire et renvoie un élément de la file ayant la plus petite priorité.\n\n\n\n\n\n","category":"method"},{"location":"#Base.popfirst!-Tuple{STSP.AbstractQueue}","page":"STSP.jl","title":"Base.popfirst!","text":"popfirst!(q)\n\nRetire et renvoie le premier élément d'une file abstraite.\n\n\n\n\n\n","category":"method"},{"location":"#Base.push!-Union{Tuple{U}, Tuple{PrimPriorityQueue, String, U}} where U","page":"STSP.jl","title":"Base.push!","text":"push!(q, name, priority)\n\nRajoute une paire identifiant priorité à une file de priorité de Prim. \n\n#Arguments\n\nq (PrimPriorityQueue): La file de priorité permettant une implémentation efficace de l'algorithme de Prim.\nname (String): Un identifiant de noeud qu'on ajoute à la file de priorité.\npriority (U): La priorité de l'identifiant dans la file dont le type est celui des poids des arêtes du graphe que l'algorithme de Prim résout.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{AbstractNode}","page":"STSP.jl","title":"Base.show","text":"\tshow(node::AbstractNode)\n\nAffiche un noeud.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{Graph}","page":"STSP.jl","title":"Base.show","text":"show(graph::Graph)\n\nAffiche un graphe.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{STSP.AbstractQueue}","page":"STSP.jl","title":"Base.show","text":"show(q)\n\nAffiche les éléments d'une file abstraite.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Union{Tuple{STSP.AbstractEdge{U}}, Tuple{U}} where U","page":"STSP.jl","title":"Base.show","text":"show(edge::AbstractEdge{T,U})\n\nAffiche une arête.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.add_adjacency!-Union{Tuple{U}, Tuple{Dict{String, Array{Edge{U}, 1}}, Edge{U}}} where U","page":"STSP.jl","title":"STSP.add_adjacency!","text":"add_adjacency!(adjacency::Dict{String, Vector{Edge{U}}}, edge::Edge{U})\n\nAjoute une arête à un dictionnaire d'adjacence.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.add_edge!-Union{Tuple{U}, Tuple{T}, Tuple{Graph{T, U}, Edge{T}}} where {T, U}","page":"STSP.jl","title":"STSP.add_edge!","text":"add_edge!(graph::Graph{T,U}, edge::Edge{T})\n\nAjoute une arête au graphe. Met également à jour le dictionnaire d'adjacence du graphe. Si l'identifiant de l'arête existe déjà dans le graphe, une erreur est renvoyée. Si les identifiants de noeuds correspondant à l'arête n'existent pas dans le graphe, une erreur est renvoyée.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.add_edge-Union{Tuple{U}, Tuple{T}, Tuple{Graph{T, U}, Node{T}, Node{T}, U}} where {T, U<:Number}","page":"STSP.jl","title":"STSP.add_edge","text":"add_edge(graph::Graph{T,U}, node_1::Node{T}, node_2::Node{T}, weight::U)\n\nFonction de commodité. Crée dynamiquememnt une arête à partir des noeuds node_1 et node_2. L'information est vue comme un poids : l'argument weight doit être un nombre.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.add_node!-Union{Tuple{U}, Tuple{T}, Tuple{Graph{T, U}, Node{T}}} where {T, U}","page":"STSP.jl","title":"STSP.add_node!","text":"add_node!(graph::Graph{T,U}, node::Node{T})\n\nAjoute un noeud au graphe. Si l'identifiant du noeud existe déjà dans le graphe, une erreur est renvoyée.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.adjacency-Union{Tuple{Array{Edge{U}, 1}}, Tuple{U}} where U","page":"STSP.jl","title":"STSP.adjacency","text":"Construit un dictionnaire d'adjacence à partir d'une liste d'arêtes.\n\nExemple:\n\n    arête1 = Edge(\"E19\", 50000, \"Bruxelles, \"Anvers\")\n    arête2 = Edge(\"E40\", 35000, \"Bruxelles\", \"Gand\")\n    arête3 = Edge(\"E17\", 60000, \"Anvers\", \"Gand\")\n    arêtes = Vector{Edge{Int}}[arête1,arête2,arête3]\n    adjacency(arêtes) = \n        (\"Bruxelles\" => [arête1, arête2], \"Gand\" => [arête2, arête3], \"Anvers\" => [arête1, arête3]).\n\n\n\n\n\n","category":"method"},{"location":"#STSP.data-Tuple{AbstractNode}","page":"STSP.jl","title":"STSP.data","text":"data(node::AbstractNode)\n\nRenvoie les données contenues dans le noeud.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.edges-Tuple{STSP.AbstractGraph}","page":"STSP.jl","title":"STSP.edges","text":"edges(graph::AbstractGraph)\n\nRenvoie la liste des arêtes d'un graphe.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.find-Tuple{Forest, String}","page":"STSP.jl","title":"STSP.find","text":"find(forest, node_id)\n\nRetourne la racine de l'arbre associé au noeud d'identifiant node_id dans la forêt forest. Itère de parent en parent jusqu'à trouver un identifiant dont le parent est lui-même.\n\nArguments\n\nforest (Forest): forêt dans laquelle rechercher l'arbre auquel est rattaché le noeud\nnode_id (String): identifiant du noeud à rechercher dans la forêt\n\nExemple\n\njulia> find(\"24\", forest)\nTree(\"7\", 12)\n# Le noeud d'identifiant \"24\" est contenu dans l'arbre de la forêt dont la racine est d'identifiant \"7\", et de taille 12.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.is_empty-Tuple{STSP.AbstractQueue}","page":"STSP.jl","title":"STSP.is_empty","text":"is_empty(q)\n\nIndique si une file abstraite est vide.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.kruskal-Union{Tuple{Graph{T, U}}, Tuple{U}, Tuple{T}} where {T, U}","page":"STSP.jl","title":"STSP.kruskal","text":"kruskal(G; mode)\n\nImplémentation de l'algorithme de Kruskal pour identifier un arbre de recouvrement minimal d'un graphe. Renvoie un tuple contenant le coût et une liste des arêtes formant l'arbre de poids minimal. Si le graphe n'est pas connexe, une erreur est renvoyée.\n\nArguments\n\nG (Graph): le graphe dans lequel il faut identifier un arbre de recouvrement minimal\nmode (String=\"size\"): (\"size\" ou \"rank\"). Précise le mode d'union entre les composantes connexes qui doit être utilisé.\n\nType de retour\n\nFloat64, Vector{Edge}\n\nExemples\n\njulia> kruskal(graph, mode=\"rank\")\n\n\n\n\n\n","category":"method"},{"location":"#STSP.n_nodes_to_read-Tuple{String, Int64, Int64}","page":"STSP.jl","title":"STSP.n_nodes_to_read","text":"nnodesto_read(format::String, n::Int, dim::Int)\n\nFonction auxiliaire de read_edges, qui détermine le nombre de noeud à lire en fonction de la structure du graphe.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.name-Tuple{Any}","page":"STSP.jl","title":"STSP.name","text":"name(n::Any)\n\nRenvoie le nom de l'objet passé en argument.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.nb_edges-Tuple{STSP.AbstractGraph}","page":"STSP.jl","title":"STSP.nb_edges","text":"nb_edges(graph::AbstractGraph)\n\nRenvoie le nombre d'arêtes d'un graphe.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.nb_nodes-Tuple{STSP.AbstractGraph}","page":"STSP.jl","title":"STSP.nb_nodes","text":"nb_nodes(graph::AbstractGraph)\n\nRenvoie le nombre de noeuds du graphe.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.nodes-Tuple{STSP.AbstractGraph}","page":"STSP.jl","title":"STSP.nodes","text":"nodes(graph::AbstractGraph)\n\nRenvoie la liste des noeuds du graphe.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.plot_graph","page":"STSP.jl","title":"STSP.plot_graph","text":"Affiche un graphe étant donnés un ensemble de noeuds et d'arêtes.\n\nExemple :\n\ngraph_nodes, graph_edges = read_stsp(\"bayg29.tsp\")\nplot_graph(graph_nodes, graph_edges)\nsavefig(\"bayg29.pdf\")\n\n\n\n\n\n","category":"function"},{"location":"#STSP.plot_graph-Tuple{Graph}","page":"STSP.jl","title":"STSP.plot_graph","text":"Trace un graphe directement depuis un objet Graph.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.plot_graph-Tuple{String}","page":"STSP.jl","title":"STSP.plot_graph","text":"Fonction de commodité qui lit un fichier stsp et trace le graphe.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.prim-Union{Tuple{Graph{T, U}}, Tuple{U}, Tuple{T}} where {T, U}","page":"STSP.jl","title":"STSP.prim","text":"prim(G)\n\nImplémentation de l'algorithme de Prim, le premier noeud est choisi aléatoirement parmi les noeuds du graphe. Si le graphe n'est pas connexe, une erreur est renvoyée.\n\nArguments\n\nG(Graph): le graphe sur lequel on exécute l'algorithme de Prim\n\n\n\n\n\n","category":"method"},{"location":"#STSP.prim-Union{Tuple{U}, Tuple{T}, Tuple{Graph{T, U}, String}} where {T, U}","page":"STSP.jl","title":"STSP.prim","text":"prim(G, initnodeid)\n\nImplémentation de l'algorithme de Prim. Si le graphe n'est pas connexe, une erreur est renvoyée.\n\nArguments\n\nG(Graph): le graphe sur lequel on exécute l'algorithme de Prim\ninitnodeid (String): l'identifiant du noeud initial\n\n\n\n\n\n","category":"method"},{"location":"#STSP.read_edges-Tuple{Dict{String, String}, String}","page":"STSP.jl","title":"STSP.read_edges","text":"read_edges(header::Dict{String}{String}, filename::String)\n\nAnalyse un fichier .tsp et renvoie une liste d'arêtes sous forme brute de tuples.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.read_header-Tuple{String}","page":"STSP.jl","title":"STSP.read_header","text":"read_header(filename::String)\n\nAnalyse un fichier .tsp et renvoie un dictionnaire avec les données de l'entête.\n\n\n\n\n\n","category":"method"},{"location":"#STSP.read_nodes-Tuple{Dict{String, String}, String}","page":"STSP.jl","title":"STSP.read_nodes","text":"read_nodes(header::Dict{String}{String}, filename::String)\n\nAnalyse un fichier .tsp et renvoie une liste d'objets de type Node. Si les coordonnées ne sont pas données, les noeuds sont instanciés avec leur identifiant et NaN`. Le nombre de noeuds est dans header[\"DIMENSION\"].\n\n\n\n\n\n","category":"method"},{"location":"#STSP.read_stsp-Tuple{String}","page":"STSP.jl","title":"STSP.read_stsp","text":"read_stsp(filename::String; quiet::Bool=true)s\n\nLit un fichier .tsp et instancie un objet Graph correspondant après avoir construit ses noeuds et ses arêtes.\n\n\n\n\n\n","category":"method"}]
}
